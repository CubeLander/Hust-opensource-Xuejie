- [第一章 计算机系统概述](#第一章-计算机系统概述)
  - [计算机系统的性能评价](#计算机系统的性能评价)
    - [非时间指标](#非时间指标)
    - [时间指标](#时间指标)
- [第二章 数据信息的表示](#第二章-数据信息的表示)
  - [数值数据的表示](#数值数据的表示)
    - [数的机器码表示](#数的机器码表示)
    - [定点数表示](#定点数表示)
      - [C语言中的整数](#c语言中的整数)
    - [浮点数表示](#浮点数表示)
  - [数据信息的校验](#数据信息的校验)
    - [码距与校验](#码距与校验)
    - [奇偶校验](#奇偶校验)
      - [奇偶校验性能](#奇偶校验性能)
    - [海明校验](#海明校验)
      - [可检一位错海明码](#可检一位错海明码)
      - [(n,k)码校验分组设计方法](#nk码校验分组设计方法)
      - [海明码特点](#海明码特点)
    - [循环冗余校验](#循环冗余校验)
      - [模2运算规则](#模2运算规则)
      - [CRC编码规则](#crc编码规则)
      - [生成多项式](#生成多项式)
      - [模2除法满足结合律](#模2除法满足结合律)
      - [CRC (n,k)码检错性能](#crc-nk码检错性能)
- [第三章 运算方法与运算器](#第三章-运算方法与运算器)
  - [定点加减法运算](#定点加减法运算)
    - [溢出及检测](#溢出及检测)
    - [加减法的逻辑实现](#加减法的逻辑实现)
      - [一位全加器逻辑实现](#一位全加器逻辑实现)
      - [减法的球阀](#减法的球阀)
      - [串行加法器时延](#串行加法器时延)
      - [并行加法器](#并行加法器)
      - [成组进位生成\&传递函数](#成组进位生成传递函数)
  - [定点乘法运算](#定点乘法运算)
      - [原码乘法运算](#原码乘法运算)
      - [补码一位乘法](#补码一位乘法)
      - [阵列乘法器](#阵列乘法器)
      - [整数的乘运算](#整数的乘运算)
  - [定点除法运算](#定点除法运算)
      - [恢复余数的除法](#恢复余数的除法)
      - [不恢复余数的除法](#不恢复余数的除法)
  - [浮点运算](#浮点运算)
      - [精度问题](#精度问题)
    - [浮点数乘法运算](#浮点数乘法运算)
    - [浮点数除法运算](#浮点数除法运算)
  - [运算器](#运算器)
    - [运算器功能](#运算器功能)
    - [运算器与总线结构](#运算器与总线结构)
- [第四章 存储系统](#第四章-存储系统)
  - [存储器概述（不重要）](#存储器概述不重要)
  - [半导体存储器](#半导体存储器)
      - [存储器的刷新](#存储器的刷新)
    - [半导体存储器的对比](#半导体存储器的对比)
  - [主存的组织以及](#主存的组织以及)
    - [存储器扩展](#存储器扩展)
      - [字长扩展(DBUG)](#字长扩展dbug)
      - [字数扩展(ABUS)](#字数扩展abus)
      - [综合扩展](#综合扩展)
  - [并行主存系统](#并行主存系统)
  - [高速缓冲存储器](#高速缓冲存储器)
    - [cache写操作流程](#cache写操作流程)
    - [cache的基本概念](#cache的基本概念)
    - [cache读写流程](#cache读写流程)
    - [关键技术](#关键技术)
      - [数据查找](#数据查找)
        - [相联存储器](#相联存储器)
      - [地址映射](#地址映射)
        - [全相连映射](#全相连映射)
        - [直接相连映射](#直接相连映射)
        - [组相连存储器硬件开销](#组相连存储器硬件开销)
      - [替换策略](#替换策略)
      - [写入策略](#写入策略)
    - [cache对存储系统性能的影响](#cache对存储系统性能的影响)
    - [cache命中率](#cache命中率)
  - [虚拟存储器](#虚拟存储器)
    - [虚拟地址到物理地址](#虚拟地址到物理地址)
    - [使用TLB提高速度](#使用tlb提高速度)
- [第五章 指令系统](#第五章-指令系统)
  - [指令格式](#指令格式)
  - [寻址方式](#寻址方式)
    - [指令寻址](#指令寻址)
      - [顺序寻址](#顺序寻址)
      - [跳跃寻址](#跳跃寻址)
    - [操作数寻址](#操作数寻址)
      - [硬件堆栈](#硬件堆栈)
    - [x86系列支持多种寻址方式的意义](#x86系列支持多种寻址方式的意义)
  - [指令格式设计](#指令格式设计)
  - [CISSC与RISC](#cissc与risc)
    - [RISC](#risc)
  - [指令系统举例](#指令系统举例)
    - [MIPS32指令格式](#mips32指令格式)
- [第六章 中央处理器](#第六章-中央处理器)
  - [概述](#概述)
  - [指令周期](#指令周期)
    - [指令执行一般流程](#指令执行一般流程)
    - [指令周期基本概念](#指令周期基本概念)
  - [数据通路及指令操作流程](#数据通路及指令操作流程)
      - [D触发器定时模型](#d触发器定时模型)
  - [时序与控制](#时序与控制)
    - [中央处理器时序](#中央处理器时序)
      - [传统三级时序](#传统三级时序)
    - [控制方式](#控制方式)
    - [时序发生器](#时序发生器)
    - [指令周期方框图](#指令周期方框图)
  - [单总线MIPS CPU典型指令](#单总线mips-cpu典型指令)
    - [取指令数据通路](#取指令数据通路)
    - [lw指令执行数据通路](#lw指令执行数据通路)
    - [sw指令执行数据通路](#sw指令执行数据通路)
    - [beq指令数据通路](#beq指令数据通路)
    - [I型运算类指令执行数据通路](#i型运算类指令执行数据通路)
    - [R型运算类指令执行数据通路](#r型运算类指令执行数据通路)
  - [硬布线控制器](#硬布线控制器)
  - [微程序控制器](#微程序控制器)
    - [单总线CPU微指令构造](#单总线cpu微指令构造)
    - [微命令编码](#微命令编码)
  - [异常与中断处理](#异常与中断处理)
- [第九章 输入输出系统](#第九章-输入输出系统)
  - [输入输出设备与特性](#输入输出设备与特性)
    - [输入/输出系统的组成与功能](#输入输出系统的组成与功能)
  - [I/O接口](#io接口)
  - [数据传送控制方式](#数据传送控制方式)
  - [程序控制方式](#程序控制方式)
  - [程序中断方式](#程序中断方式)
  - [DMA方式](#dma方式)
  - [通道方式](#通道方式)
  - [常见I/O设备](#常见io设备)
- [错题总结话术：](#错题总结话术)

# 第一章 计算机系统概述
## 计算机系统的性能评价
### 非时间指标
+ 机器字长
  + 机器一次性能够处理的二进制位数（一般于内部寄存器的位数相等）
+ 总线宽度
  + 数据总线一次能并行传送的最大信息位数
+ 主存容量与存储带宽
  + 容量：一台计算机主存包含的存储单元总数
  + 带宽：单位时间内与贮存你交换的二进制信息量，Byte/s

### 时间指标
+ 主频
  + CPU工作的时钟频率，与CPU运算能力之间**不是**唯一的、直接关系
+ 时钟周期$T=\frac{1}{f}$
  + 计算机中最基本的、最小的时间单位。一个时钟周期CPU仅完成一个最基本动作
+ 外频
  + 系统总线的工作频率，CPU与主板之间同步运行的速度
+ 倍频
  + $主频=外频 \times 倍频$
+ CPI
  + 执行一条指令（平均）需要的始终周期数
$$CPI = 一段程序中所有指令的始终周期之和/指令条数 = 程序中各类指令的CPI \times 程序中各类指令的比例 $$
+ MIPS
  + $$ MIPS =  \frac{指令条数}{执行时间 \times 10^6} = \frac{指令条数}{所有指令CPU始终周期数之和/f \times 10^6} = \frac{f}{CPI \times 10^6} = IPC * f $$
  + 程序执行时间
    + $$ T_e = \frac{指令条数}{MIPS \times 10^6} $$

# 第二章 数据信息的表示
## 数值数据的表示
### 数的机器码表示
+ 真值： 带正负号的
+ 机器码
  + 原码：
    + 区间$(-2^n, 2^n)$
  + 反码
    + 符号与原码相同，正数与原码相同，负数除符号位其它二进制位取反
  + 补码
    + 正数和原码相同，符号位为0
    + 负数逐位取反，末位加1，符号位为1
    + 特性：
      + 唯一0
      + 区间：小数$[-1,1)$，整数$[-2^n, 2^n)$
      + 非对称区间，左侧多一个数
    + 双符号位补码
      + 符号位01表示正溢出，10表示负溢出，最高位表示正确的符号位
  + 移码
    + $$ [x]_{mov} = 2^n + x \quad -2^n <= x <= 2^n $$
    + 与补码的符号位相异，数值位相同

### 定点数表示
#### C语言中的整数
+ 有符号和无符号共存时无符号优先
+ 整数变量初始化
  + 先按照约定处理常量转换成机器码
  + 根据变量长度进行强制转换，超出位数截断

### 浮点数表示
+ 机器字长一定时，阶码越长，表示范围越大，精度越高（规格化）
+ 阶码相同，尾数越长，精度越高
+ 扩大了表示范围，未增加状态数
+ 绝对值越大，浮点数分布越系数，运算不满足结合律

## 数据信息的校验
### 码距与校验
+ 码距： 任意两个合法编码间不同的二进制位数
+ 码距越大，抗干扰能力越、纠错能力越强，数据荣誉越大，编码效率越低
+ 最小码距>=e+1
  + 可检测e个错误
+ 最小码距>=2t+1
  + 可纠正t个错误
+ 最小码距>=e+t+1
  + 可纠正t个错误，同时需要检测e个错误 

### 奇偶校验
+ 奇校验
  + 冗余位： 1位，检验位P
  + 编码规则：校验码（数据+校验位）中的1的个数位奇数
$$ 偶校验：P = D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 $$
$$ 奇校验：P = \neg (D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8) $$
$$ 检错码：G = P \oplus D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 $$
G=1：数据一定出错，否则较大概率正常

#### 奇偶校验性能
识别奇数错，不能纠错，不保证正确，实现简单，编码效率高

### 海明校验
+ 多i个就教研组
+ 既能检错，也能纠错
+ 最小码距为3
+ 最低位从1开始

#### 可检一位错海明码
+ 编码规则：分组交叉就检验法
  + 戴编码数据分成r个就校验组
  + r位校验位（冗余），生成r位检错码
  + 各数据位至少参加2各校验组
  + 一个数据位出错，可导致多个检错码为1
+ 检错纠错：检错码值表示出错位置（假设一位错）
  + 检错码全0，数据大概率正常，最低位是1开始
  + 可检错，也可纠错，将出错位取反即可

(n,k)海明码共n位，其中数据位k位，校验位r位，
$$ n=k+r <= 2^r -1 $$
#### (n,k)码校验分组设计方法
+ 校验码$P_i$放置在$H_{2^i-1}$索引处
+ 数据位放在剩下的位置。
+ $H_i$的二进制表示的低$j$位为1，则$G_j$组需要包含$H_i$
+ $P_i$负责校验二进制表示的低$j$位为1的$H_j$的数据
```
eg:
  (8,4)码
  P3 = H5 ^ H6 ^ H7 ^ H12
```

#### 海明码特点
+ 编码效率高
+ 可纠正一位错
+ **在假设没有三位错的情况下，如何区别一位还是两位错**
  + 引入总校验位
  + 报错字=1，总校验位=1，一位错。
  + 报错字=1，总校验位=0，两位错。

### 循环冗余校验
+ 编码规则：编码可被生成多项式整除
  + 模2除法，余数为0（高概率正确），否则出错
+ 设CRC码为n位，其中数据位k位，校验位r位
  + $$ n = k + r <= 2^r -1 $$

#### 模2运算规则
除法：余数首位为1，商上1，否则为0

#### CRC编码规则
+ 将待编码的k位有效信息位组表达为多项式$M(x)$   
  + $$ M(x) = b_{k-1}x^{k-1} + b_{k-2}x^{k-2}+...+b_1x+b_0 \quad x=2 $$
+ 将数据左移r位，空出r位校验（冗余位），变成 $M(x) \cdot x^r$
+ 将 $M(x) \cdot x^r$ 除以生成多项式$G(x)$,商为$Q(x)$，余数$R(x)$
  + $$ M(x) \cdot x^r = Q(x) \cdot G(x) +R(x) $$
+ 将余数填充在校验位
  + $$ M(x) \cdot x^r + R(x) = Q(x) \cdot G(x) + R(x) + R(x) = Q(x) \cdot G(x) $$

编码规则：CRC编码可被$G(x)$表示的编码整除

**出错**：  
当只有一位错的时候，余数的“1”在第几位，就说明是第几位处所。如余数`010000`，表示第5位出错。

#### 生成多项式
+ 生成多项式特征
  + 任意1位发生错误余数均不为0
  + 不同位发生错误余数不同
  + 余数左移一位继续作模2除，应使余数循环，循环周期$N=k+r$
+ 如何产生生成多项式
  + (n,k)码，将$X^n+1$分解为若干质因子
  + 根据码距要求选择其中的因式或多个因式的成绩为生成多项式

>
> eg：
> $$ x^7+1=(x+1)(x^3+x+1)(x^3+x^2+1) $$
> $G(x)$可以为多种取值  
> $G(x)=x+1=11$ (7,6)码，判一位错  
> $G(x)=x^3+x+1=1011$ 或 $G(x)=x^3+x^2+1$ (7,4)码，两位错，一位错余数均不为0，但余数有重叠  
> $G(x)=(x+1)(x^3+x+1)=11101$  
> 如果使用$G(x)=1011$来编码  
> $$ 1100_2 <<3 \div = 1110_2 \quad ... \quad 010_2 $$
> 原始数据`1100`,编码后的数据`1100` `010`

#### 模2除法满足结合律
+ 两数的余数异或等于两数异或后的余数
  + $$(M(x) \% G(x)) \oplus (N(x)\%G(x)) = (M(x) \oplus N(x)) \% G(x) $$
+ 利用模2除法的结合律可以实现并行CRC电路

|串行CRC|并行CRC|
|:--|:--|
|时序|组合|
|多周期|单周期|
|慢|块|
|硬件少|硬件多|

#### CRC (n,k)码检错性能
$r=n-k$

+ 所有小于等于r长度的突发错误
  + 突发错长度：第一和最后错位之间的距离
+ $(1-2^{-r+1})$比例的$r+1$长度的突发错
+ $(1-2^{-r})$比例的大于$r+1$长度的突发错
+ 所有小于最小码距的任意位数的错误
+ 如果生成多项式中1的数目位偶数，可检测所有奇数错


# 第三章 运算方法与运算器
## 定点加减法运算
### 溢出及检测
+ 单符号数溢出检测1
  + 正正得负 负负得正
  + 设量符号位为$f_0$$f_1$，和数符号位$f_s$
  + 溢出检测信号`Overflow` = $\hat f_0 \hat f_1 f_s + f_0f_1 \hat f_s$
+ 单符号溢出检测方法2
  + 符号位进位位$C_f$，最高位进位位$C_n$
  + $Overflow=C_f \oplus C_n$
+ 双符号溢出检测方法
  + $01$正溢出，$10$负溢出

### 加减法的逻辑实现
#### 一位全加器逻辑实现
$$ S_i = X_i \oplus Y_i \oplus C_i $$
$$ C_{i+1} = X_i Y_i + (X_i \oplus Y_i) C_i $$
得到$C_{i+1}$五级门电路延迟，得到$S_i$六级门电路延迟

#### 减法的球阀
引入运算控制位`Sub`
`Sub`=1时候做减法，送入加法器的是$[-Y_{补}]$
$$ Input = Y_i \oplus Sub$$

#### 串行加法器时延
获得$C_n$的时间$(2n+3)T$，获得$S_{n-1}T$的时间$(2n+4)T$，获得`overflow`需要$(2n+6)T$

#### 并行加法器
$$ G_i = X_i Y_i \qquad P_i = X_i \oplus Y_i $$
$$ C_{i+1} = G_i + P_i C_i $$ 
$$ C_n = G_{n-1}+P_{n-1}G_{n-2} + P_{n-1}P_{n-2}G_{n-3}+...+P_{n-1}P_{n-2}...P_1P_0C_0 $$
+ 进位输出仅与最低位进位输入$C_0$有关
+ 位数预测长，进位链电路复杂度越高
+ 通常按照*4位一组*进行分组运算
+ $$ C_4 = G_3 + P_3G_2+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0 $$
+ 生成、传递函数电路就是普通的与门、异或门阵列，可以并行输出所有$G_i$$P_i$的值，3级门电路延迟
+ 并行进位电路2级门电路延迟
+ 进位信号得到后，求和值需要一级异或门延迟3T即可完成
+ 4个一组时，最高位进位$C_4$延迟$5T$，结果$S_i$延迟$8T$
+ 16位加法器，组内先行进位，组间串行进位，获得结果延迟$14T$,获得最高位进位延迟$11T$
#### 成组进位生成&传递函数
$$ P^{*} = P_3P_2P_1P_0 $$
$$ G_{*} = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 $$
$$ C_4 = G^{*} + P^{*}C_0 $$

16位先行进位  
生成$P^{*},G^{*}$只需$5T$  
生成$C_{12}$只需$2T$  
计算进位$2T$,求和$3T$  
总共12级门电路延迟

64位先行进位 --> 16级门电路延迟
## 定点乘法运算
#### 原码乘法运算
$$ [X \times Y]_{原} = X \times [Y_12^{-1}+Y_22^{-2}+...+Y_n2^{-n}] $$
从$Y$的最低位开始；$\sum$从0开始采用双符号位；$X$也采用双符号位；根据$Y_i$的值判断是加$X$还是加0。加完以后$\sum$,$X$,$Y$都逻辑右移。$\sum$可能瞬间溢出，但是移位后正常。最终结果是$\sum$加上移出的部分。
#### 补码一位乘法
$$ [X \times Y]_{补} = [X]_{补} \times 0.Y_1Y_2...Y_n - Y_0[X]_{补} $$
$$ = [X]_{补} \times [Y_1-Y_0+(Y_2-Y_1)2^{-1}+(Y_3-Y_2)2^{-2}+...(0-Y_n)2^{-n}] $$
大概类似原码乘法，也$\sum$和$X$也使用双符号位，但是在判断$\sum$是加什么出，如果$Y_nY_{n+1}$为10，则$\sum +-[-X]_{补}$;若$Y_nY_{n+1}$为01，$\sum += [X]_{补}$;其它情况则+0.右移仍然照做。

![补码乘法](整理/补码乘法.png)
上面的右移是算数右移！
#### 阵列乘法器
横向进位乘法器  
延迟会比斜向进位乘法器更高，但是设计简单。  
两个五位数乘法，横向乘法进位器时延39T，但是斜向进位乘法进位器时延37T

斜向进位乘法器
+ 总共$n*(n-1)$个全加器
+ $(n-1) FA + (2(n-1)+4)T+T$，其中`FA`是全加器
+ $(8n-3)T$的时延

#### 整数的乘运算
+ 硬件不判断溢出，保留2n位成绩，供软件使用
+ 程序不判断溢出，编译器也不生成用于溢出处理的代码，会发生整数溢出问题

## 定点除法运算
#### 恢复余数的除法
被除数和除数都使用双符号位，先尝试减除数。如果余数小于0，则再加回余数，商为0。否则商为1.余数左移，然后再减除数。  

最后获得的余数是放大了的，商有几位，余数就需要乘$2^{-n}$。
#### 不恢复余数的除法
+ 第一次一定做减法
+ 商$Q_n = ~R_0$（余数符号位）
+ $R=(R+(-1)^{Q_n}Y)*2$
+ 最后仍然要余数缩小

原码阵列除法器

`FA`加上加减控制变成“可控制加、减法单元”`CAS`，时延9T  
原码阵列除法器需要n*n个`CAS`,时延$n*n*9T$
## 浮点运算
浮点计算步骤：对阶、尾数运算、规格化、舍入、溢出判断
+ 对阶
  + 小阶对大阶 尾数右移
+ 运算结果规格化
  + 目的：保证浮点数的编码唯一性
  + 形式：尾数非0时，要求绝对值>=0.5，尾数MSB=1.否则修改阶码并移动尾数，使其满足要求
  + 右规：右移实现规格化，阶码+
  + 左规：左移实现规格化，阶码-

#### 精度问题
IEEE754在结果右边增加2个附加位
+ 保护位Guard：在最低有效位右边的位
+ 舍入位Round：在保护位右边的位

### 浮点数乘法运算
1. 阶码相加
  + 阶码相加可能产生溢出，要进行溢出判断
2. 尾数相乘
  + 尾数相乘可得到积的尾数，可按定点乘法运算方法运算
3. 结果规格化

### 浮点数除法运算
1. 尾数调整
  + 如果被除数尾数大于除数尾数（绝对值），则将被除数尾数右移一位，阶码+1
2. 阶码求差
  + 商的阶码等于被除数的阶码减去除数的阶码
3. 尾数相除

## 运算器
### 运算器功能
+ 算数运算和逻辑运算
  + 运算电路
+ 暂存运算数据以及中间结果
  + 暂存器，通用寄存器
+ 选取数据参与运算
  + 多路选择、数据通路
+ 反应运算处理的状态
  + 程序状态字

### 运算器与总线结构
单总线结构的时候，完成一次`ADD R0, R1`,需要3个时钟周期。  
分别是传入第一个操作数，传入第二个操作数，写回结果。

双总线+1个锁存器，2个时钟周期。  
第一个周期取第一个操作数放到锁存器中。第二个周期传入第二个操作数以后获得结果就可以立刻写回了。因为第二个操作数走的总线是单独的。但是第一个操作数和写回结果走的总写是一条。

也可以第一个操作数和第二个操作数在第一个周期就同时传入ALU，但是结果先写到锁存器中。等第二个周期再写回通用寄存器中。

# 第四章 存储系统
## 存储器概述（不重要）
+ 按存取方式分
  + 随机存储器
    + 存取时间与物理位置无关
    + 磁芯、半导体存储器
  + 顺序存储器
    + 存取内容只能按地址顺序访问
    + 磁带
  + 直接存储器
    + 不必顺序访问，但是存取时间与物理位置有一定关系
    + 磁盘（机械硬盘）、激光存储器
    + 因为它自己可以寻址

## 半导体存储器
#### 存储器的刷新
+ 集中刷新
  + 刷新周期：2ms
  + 在数据丢失之前集中刷新所有行
  + 存在死区，用在实时要求不高的场合
+ 分散刷新
  + 最大刷新周期：2ms
  + 存储周期：读写+刷新，各刷新周期分散安排在存取周期中
  + 刷新次数 2ms/100ns=20000次，比较浪费，用在低速系统中
+ 异步刷新
  + 刷新周期：2ms，各刷新周期分散安排在2ms内
  + 每隔2ms/128=15.5微妙刷新一行，将128次刷新分散
  + 最常用

### 半导体存储器的对比
|SRAM | DRAM | ROM | PROM | EPROM | EEPROM |
|:----|:-----|:----|:-----|:------|:-------|
|MOS管| 电容 | 开关 | 熔丝  | 浮置栅| 浮置栅|
|快   | 慢   | 只读  | 写一次|高压写入|高压写入|
|6MOS | 1MOS+1C|  |    |     紫外线擦|控制栅极|
|功耗高| 价格便宜|    |      |离线擦除|在线电擦|
|    | 动态刷新|    |    |   擦后写|   擦后写|
|    | 行列分开     |    |         |         |
## 主存的组织以及
### 存储器扩展
+ 字长扩展（数据总线扩展）
  + 各芯片并行工作
+ 字数扩展（地址总线扩展）
  + 同一时刻仅一芯片工作
#### 字长扩展(DBUG)
存储系统位宽N位，若使用k位芯片，k<N,需要(N/k)个芯片
#### 字数扩展(ABUS)
存储系统容量位M，若使用容量为I的芯片，I<M，需要（M/I）个芯片
#### 综合扩展
存储系统$M*N$位，若使用$I*k$位芯片，$I<M,k<N$,需要$(M/I)*(N/k)$个芯片

*（大概是懂了这个类型的连线题怎么玩了）*
## 并行主存系统
CPU与存储器之间的速度无法匹配
+ 解决方法
  + 增加Cache(行缓冲)
  + 采用高速器件提高速度
  + 采用双端口存储器
  + 增加字长，单个存储周期存取多个字
  + 将主存划分为多个模块，多模块并行

+ 多模块顺序存储器（存储扩展）
  + 一个地址寄存器
  + 高位片选，多模块串行
  + 扩容方便
  + 性能无提升
  + 方便故障隔离
+ 多模块交叉存储器
  + 模块并行工作
  + CPU比存储器要快
  + 能同时取出多条指令或者数据
  + 扩容、提速

## 高速缓冲存储器
### cache写操作流程
+ 写穿策略
  + 无脏数据，无丢失数据风险，写速度慢
+ 写回策略
  + 存在脏数据，有丢失数据风险，突发写速度快，持续写性能
### cache的基本概念
+ 命中：CPU访问数据在cache中（上层快存）
+ 缺失：CPU访问数据不再cache中
+ 块：cache与主存交换最小单位
+ 行/槽 Line/Slot：标记、标志位、数据块容器
  + 有效位、查找标记、脏标志位、置换标志、数据块副本
+ 命中率、缺失率
+ 命中访问时间
  + 数据查找时间、cache访问时间、总线传输时间
+ 缺失损失
  + 主存块调入cache，数据传输到处理器的时间
  + 远大于命中时间，所以一些相对较小的时间可以忽略
+ 数据替换：cache满了以后进行替换
+ 脏数据逐出：当一个cache已经被修改过，必须得写回到下一级存储器，才可以丢弃。

### cache读写流程
+ CPU cache系统读过程
  + CPU给出主存地址（块地址，块内地址）
  + 主存块地址为关键字进行查找
  + 如相符表示副本在cache中，命中，访问cahce
  + 否则数据缺失，访问主存
    + 将数据所在块副本调入cache（块交换--局部性）
    + 载入副本过程可能引起替换（时间长）
    + 更新查找表，记录当前数据块地址
    + cache缺失时CPU只能挂起等待
+ CPU cache系统写过程
  + CPU给出主存地址
  + 主存块地址为关键字进行查找
    + 相符则表示命中，数据副本在cache中
    + 缺失根据写分配策略决定是否将该主存地址对应数据块调入
  + 写入数据到cache
  + 根据写策略决定是否写入主存

### 关键技术
#### 数据查找
##### 相联存储器
+ 按内容进行访问(key, value)
  + 以关键字作全局全局并发比较，硬件成本高（比较器多）
  + 片外cache用于存放查找表
  + 片外cache村南方查找表+数据副本
  + 虚拟存储器中存放段表、页表
+ 存储容量=查找表/相联存储器容量=表项数*表项大小
  + (valid, key, value)
  + (有效位，主存块地址，cache块地址) （片外cache，存放查找表）
  + (有效位，主存块地址，cache块数据) （片内cache，存放查找表+数据副本）
  + (有效位， VPN, PPN)（虚拟存储器页表）

CPU cache基本组织方式
+ CPU cache由SRAM构成
+ cache与主存均分为固定大小的数据块，以块为单位交换数据
+ 相联存储器存放查找表/cache
  + 表项：（有效位，调入cache的主存块地址，cache块地址/块数据）
  + 容量=cache块数*表项大小
+ CPU给出的块地址与查找表中某单元相同且有效位为1表示命中

相连存储器容量
+ 查找表和缓存副本一体（CPU片内缓存）
  + 存放cache行
  + 有效位，主存块地址，数据块副本，标志位（dirty bit），置换标记
  + 存储容量=cache行大小*行数
+ 查找表和缓存副本分离（片内查找表，片外缓存）
  + 存放查找信息
  + 有效位，主存块地址，cache块地址，标志位（dikrty bit），置换标记
  + 存储容量=查找表表项大小*行数
#### 地址映射
##### 全相连映射
主存块可放置在任意cache行

cache8行，块大小4W，主存$2^9$W，cache总容量=(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数

应用场合
+ 块映射灵活，一对多映射
+ cache满后才会出现块冲突
+ 块冲突概率低，cache利用率高
+ 淘汰算法复杂
+ 命中率高

##### 直接相连映射
cache块号i，供n块，主存块号j，i=j mod n

cache8行，块大小4W，主存$2^9$W，cache总容量=(valid+查找标记位+标志位+数据块副本容量)*总行数

在全相连映射中，主存地址被解释为：区地址（tag）+行地址（索引，区内块偏移）+块内偏移

直接相连应用场合
+ 映射速度块，一对一映射，无需查表
  + 利用索引字段直接对比响应标记位即可
  + 查找表可以和副本一起存放，无需相联存储器
+ 容易冲突，cache利用率低
+ 替换算法简单
+ 命中率低，适合大容量cache

##### 组相连存储器硬件开销
+ SRAM
  + 存放数据副本
+ 多个先练存储器共享一个多路比较器
  + 相对于全相连，多路比较器复杂度低
  + 查找表表项内容（valid位，dirty位，查找标记，置换标记位）
  + 相联存储器总容量
    + cache行数*（1+1+查找标记位宽度+置换标记位）
+ 片外缓存如果查找表在CPU内部
  + 查找表中必须增加cache行地址

cache8行，块大小4W，主存$2^9$W，cache总容量=(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数

组相连映射中，主存地址被解释为：标记+组索引+块内偏移

组相连应用场合
+ 小容量cache可采用全相连映射或组相连映射
+ 大容量cache可采用直接映射方式
  + 查找速度块，命中率相对低
  + 但cache容量大可提高命中率
  + 块设备缓存

#### 替换策略
+ 先进先出FIFO
  + 可能会产生颠簸，不停的出和入
+ 最不经常使用算法LFU
  + 为缓存中的每一个数据记录是否被使用过，当需要替换的时候把使用次数最少的扔出去
+ 近期最久未使用算法LRU
  + 记录缓存中每个数据进入缓存的时间，如果hit了就归零重新记录，需要替换的时候把时间最久的扔出去

#### 写入策略
+ 写回法
+ 写穿法
+ 写分配
+ 写不分配

### cache对存储系统性能的影响
+ 读优化
  + 时间局部性
    + 将刚访问的数据调度到cache中，利用淘汰算法将不经常使用的数据淘汰
  + 空间局部性
    + 大块预读，相邻的数据被调度到cache中
+ 写优化
  + 写回策略提升突发写性能
+ 负面影响
  + 写回策略引起不一致性
  + 缓冲区满以后，写性能降低

### cache命中率
+ 命中率
  + $N_c$表示cache完成存取访问的总次数
  + $N_m$表示主存完成存取访问的总次数
  + $h=|frac{N_c}{N_c+N_m}$
+ $t_a$表示平均访问时间
  + $t_c$表示命中cache时的访问时间
  + $t_m$表示命中主存时的访问时间
  + $t_a=ht_c+(1-h)t_m$
+ 访问效率=$\frac{t_c}{t_a}$
+ 影响命中率的几个因素
  + 程序行为（局部性） 
  + cache容量
  + 组织方式
  + 块大小
## 虚拟存储器
> 为什么cache访问的时候使用的是物理地址而不是虚拟地址？
> 每个进程都使用相同的虚拟地址空间，不同进程相同虚拟地址对应的物理数据是不一样的，无法使用虚拟地址去cache中查找，导致不同进程切换时候可能会切换cache

### 虚拟地址到物理地址
当CPU要访问一个地址的时候，把虚拟地址给到MMU，MMU计算出PTEA以后给cache memeory（页表），获得对应的PTE，如果页命中，则MMU再把PA送给页表，页表取出对应物理地址处的数据送给CPU。如果页不命中，MMU抛出异常，等却也异常处理成功以后，程序会唤醒一场指令所在进程，重新再调用一次。

### 使用TLB提高速度
MMU直接把VPN到TLB中查找，如果查找成功直接可以获得对应VA的PPN，然后根据PPN得到PA，发给页表让页表把对应数据给CPU


# 第五章 指令系统
## 指令格式
+ 操作码OP与地址码AC
  + 操作码字段长度决定指令系统规模
    + 每条指令对应一个操作码
    + 定长操作码$Length_{OP}=[log_2n]$
    + 变长操作码 操作码向不用的地址码字段扩展
  + 操作数字段可能有多个
    + 寻址方式字段 长度与寻址方式种类有关，也可能隐含在操作码字段
    + 地址码字段 作用以及影响、长度和寻址方式有关

> 扩展操作码的条数的计算：
> 指令长度32位，操作数12位，剩下可以给操作码，双操作数、单操作数和无操作数
> 若双操作数有k条指令
> 单操作数$(2^8-k)\times2^{12}$，$2^{12}$是多余的12位组合
## 寻址方式
### 指令寻址
#### 顺序寻址
程序对应的机器指令序列在主存顺序存放。
执行时从第一条指令开始，逐条取出并执行。
+ 实现方式
  + 程序计数器对指令序号进行计数
  + PC存放吓一跳哈子i了那个地址,初始值为程序首地址
  + 执行一跳指令,PC=PC+当前指令字节长度
#### 跳跃寻址
当程序中出现分支或循环时,就会改变程序的执行顺序
+ 吓一跳指令地址不是PC++得到,而是由指令本身给出
+ 跳跃的处理方式是重新修改PC的内容,然后进入取指令阶段

### 操作数寻址
+ 立即寻址
  + 地址码字段是操作数本身(相当于不用寻址,直接就是操作数)
+ 直接寻址
+ 间接寻址
  + 需要两次访存,速度慢,已经淘汰
+ 寄存器寻址
+ 寄存器间接寻址
+ 相对寻址
+ 基址/变址寻址
+ 复合寻址
  
#### 硬件堆栈
栈顶不动,数据移动,也能保证栈的结构

### x86系列支持多种寻址方式的意义
+ 访问更大的存储空间
+ 访问更大的数据
+ 方便程序设计
+ 提高指令执行速度（？）

## 指令格式设计
+ 根据指令规模以及是否支持操作码扩展,确定操作码字段长度
+ 根据对操作数的要求确定地址码字段的个数
+ 根据寻址方式的要求,为各地址码字段确定寻址方式字段长度
+ 定长还是变长

## CISSC与RISC
### RISC
+ 指令条数少,只保留使用频率最高的简单指令,指令定长
  + 便于硬件实现,用软件实现复杂指令功能
+ Load/Store架构
  + 只有存/取数指令才能访问存储器,区域指令的操作数都在寄存器之间进行
  + 便于硬件实现
+ 指令长度固定,指令格式简单、寻址方式简单
  + 便于硬件实现
+ 寄存器数量多
  + 便于编译器实现
+ 一个机器周期完成一条机器指令
+ RISCCPU采用硬布线控制,CISC采用微程序
## 指令系统举例
### MIPS32指令格式
+ R型指令
  + 操作码(6)+源寄存器1(5)+源寄存器2(5)+目的寄存器(5)+偏移位移量(5)+扩展操作码(6)
  + 无寻址方式字段,隐藏在操作码字段中
+ I型指令
  + OP(6)+$R_s$(5)+$R_t$(5)+Imm(16)
+ J型指令
  + OP(6)+Imm(26)

# 第六章 中央处理器
## 概述
+ CPU的主要功能(取指令并执行指令的部件)
  + 运算器
    + 数据加工:算数/逻辑运算
  + 控制器
    + 程序控制:程序中指令执行顺序控制
    + 操作控制:将机器指令翻译成执行部件所需操作控制信号
    + 时序控制:控制操作信号产生的时间、持续时间
    + 异常控制:异常处理、外设交互
+ CPU中重要寄存器
  + PC--程序计数器
  + IR--指令寄存器(optional)
  + AR--地址寄存器(optional)
  + DR--数据缓冲寄存器(optional)
  + AC--累加寄存器(optional)
  + PSW--程序状态字(optional)
+ 操作控制器
  + 输入:机器指令
  + 输出:控制信号序列
  + 功能:循环取指、执行、处理异常
    + 将机器指令译码并生成执行部件所需的控制信号序列,控制信号按序传送至各个执行部件控点,引起逻辑门开闭,建立正确的数据通路,从而完成指令功能
  + 控制器分类
    + 应布线控制器(时序逻辑型)(硬件实现)
    + 微程序控制器(存储程序型)(软件实现)

## 指令周期
### 指令执行一般流程
取指令(PC++)->指令译码->操作数地址计算->取操作数->数据操作指令执行->操作数地址计算->存操作数->(无中断)取指令  
有中断,就等待中断响应,然后再取指令

### 指令周期基本概念
+ 时钟周期=节拍脉冲=震荡周期  能够完成一次微操作
+ 机器周期 = CPU周期  从贮存读出一跳指令的最短时间  可完成复杂操作
+ 指令周期:从贮存取一跳指令并执行指令的时间
  + 取指令周期、执行指令周期 (间址周期、中断周期)
  + 执行周期包含n个机器周期,机器周期包含k个节拍

## 数据通路及指令操作流程
+ 数据通路--执行部件间传送信息的路径(数据流)
  + 通路的建立由控制信号控制,受时钟驱动(控制流)
  + 不同指令、同一指令在执行的不同阶段的数据通路不同
  + 共享通路(总线)、专用通路
    + 指令执行流程、执行效率
    + 微操作控制信号的时序安排

#### D触发器定时模型
+ 时钟触发前输入需要稳定一段时间(建立时间) setup time
+ 时钟触发后输入需要稳定一段时间(保持时间) hold time
+ 时钟触发到输出稳定的时间(触发器延迟) Clk_to_Q

> 时钟周期>Clk_to_Q+关键路径时延+Setup time
> Clk_to_Q+最短路径时延>Hold time

## 时序与控制
### 中央处理器时序
#### 传统三级时序
+ 状态周期、节拍点位、节拍脉冲
+ 状态周期数、节拍点位数、节拍脉冲数可变

### 控制方式
+ 同步控制
  + 机器周期数、节拍数固定---3机器周期*4节拍
  + 机器周期数固定、节拍数不固定---3机器周期,取指/计算/执行 4/2/3节拍
  + 大多数指令机器周期固定
+ 异步控制
  + 无时钟,应答机制
### 时序发生器

### 指令周期方框图
+ 取指周期
  + PC->Ar, PC->X
  + X+4->Z
  + Z->PC, M[AR]->DR
  + DR->IR
+ 计算周期
  + lw指令&sw指令
    + R[rs]->X
    + X+Imm->Imm
  + beq指令
    + R[rs]->X
    + X-R[rt]->PSW
  + add&addi不需要计算周期
+ 执行周期
  + lw指令
    + Z->AR
    + M[AR]->DR
    + DR->R[rt]
  + sw指令
    + Z->AR
    + R[rt]->DR
    + DR->M[AR]
  + beq指令
    + PC->X
    + IR(A)+X->Z
    + if(PSW>equal) Z->PC
  + add指令
      + R[rs]->X
      + X+R[rt]->Z
      + Z->R[rd]
    + addi指令
      + R[rs]->X
      + X+imm->Z
      + Z->R[rt]
## 单总线MIPS CPU典型指令
| 指令 | 指令功能（RTL描述）|
|:--|:--|
|lw rt, imm(rs)|R[rt] <- M[R[rs]+SignExt(imm)]|
|sw rt, imm(rs)|M[R[rs]+SignExt(imm)]<-R[rt]|
|bewq rs, rt, imm|if(R[rs]==R[rt]) Pc<-PC+4+SignExt(imm)<<2|
|addi rt, rs, imm|R[rt]<-R[rs]+SignExt(imm)|
|add rd, rs, rt|R[rd]<-R[rs]+R[rt]|
### 取指令数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T1|PC->AR, PC->X|$PC_{out},AR_{in},X_{in}$|
|T2|X+4->Z|+4|
|T3|Z->PC, M[AR]->DR|$Z_{out},PC_{in},DRE_{in},Read$|
|T4|DR->IR|$DR_{out},IR_{in}$|
### lw指令执行数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T5|R[rs]->X|$R_{out},X_{in}$|
|T6|X+sExt(imm)->Z|$IR(I){out}, ADD$|
|T7|Z->AR|$Z_{out},AR_{in}$|
|T8|M[AR]->DR|$DRE_{in},Read$|
|T9|DR->R[rt]|$DR_{out},R_{in}$|
### sw指令执行数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T5|R[rs]->X|$R_{out},X_{in}$|
|T6|X+sExt(imm)->Z|$IR(I){out}, ADD$|
|T7|Z->AR|$Z_{out},AR_{in}$|
|T8|R[rt]->DR|$R_{out},Rs/Rt,DR_{in}$|
|T9|DR->M[AR]|$DRE_{out}, Write$|
### beq指令数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T5|R[rs]->X|$R_{out},X_{in}$|
|T6|X-R[rt]->PSW|$R_{out},Rs/Rt,SUB,PSW_{in}$|
|T7|PC->X|$PC_{out},X_{in}$|
|T8|X+sExt(imm<<2)->Z|$IR(A)_{out}, ADD$|
|T9|if(PSW.equal)Z->PC|$Z_{out},PC_{in}=PSW.equal$|
### I型运算类指令执行数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T5|R[rs]->X|$R_{out},X_{in}$|
|T6|X+sExt(imm)->Z|$IR(I)_{out}, ADD$|
|T7|Z->R[rt]|$Z_{out},R_{in}$|
### R型运算类指令执行数据通路
|节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--|
|T5|R[rs]->X|$R_{out},X_{in}$|
|T6|X+R[rt]->Z|$Rs/Rt,R_{out}, ADD$|
|T7|Z->R[rt]|$Z_{out},R_{in},RegDst$|

## 硬布线控制器

## 微程序控制器
+ 微程序是利用软件思想设计硬件的技术
+ 将控制信号序列向程序一样存储起来
  + 控制信号序列分解为若干节拍
  + 一个节拍的兵法信号编成一跳微指令
  + 多个节拍对应多条微指令,形成一段微程序
+ 依据执行微程序即可生成控制信号序列
  + 指令取指执行->微程序执行->微指令执行->生成控制信号
  + 软时序:一次执行微指令,时间信号有先后顺序
+ 存储技术和程序设计相结合,会比复杂时序逻辑设计

### 单总线CPU微指令构造
+ 操作控制字段:存储操作控制信号
  + 每一位对应一个控制信号,也称微命令,可同事给出多个操作信号
+ 顺序控制字段:用于控制微程序的执行顺序
  + 判别逻辑为零,下一条微指令地址从下址字段获取,否则按约定规则生成

### 微命令编码
  + 简单直观，便于输出控制，微指令长度太长，控存容量大
    + 直接表示->编码表示（压缩互斥性微命令）
    + 下址字段->计数器法 （$\mu$AR++,增加$P_{end}$判别位）
    + 水平型->垂直型微指令（牺牲并行性）


## 异常与中断处理
+ 内部异常（当前指令无法执行）
  + 故障fault
    + 由指令执行引起的异常，如未定义指令、越权指令、段故障、缺页故障、存储保护违例、数据未对齐、除数为0、浮点溢出、整数溢出等。
    + 可恢复的故障，指令需恢复执行；不可恢复故障，程序被终止
  + 陷阱trap
    + 是一种事先被安排的“异常”时间，通过在程序中显式的调用陷阱指令触发异常，用于在用户态下调用操作系统内核程序，如系统调用、条件陷阱指令。
  + 终止
    + 随机出现的使CPU无法继续执行的硬件故障，和具体指令无关。如机器校验错、总线错误、异常处理中再次异常的双错等，此时当前程序无法继续执行，只能终止执行，由异常服务处理程序来重启系统。
+ 外部中断（当前指令执行完毕）
  + 关中断
    + 临时禁止中断请求，使为了保障中断响应周期以及中断服务程序中保护现场操作的完整性
  + 保存断点
    + 保存将来返回被中断程序的位置，对于已经执行完毕的指令其断点是下一条指令的位置（可能不是顺序指令），对于缺页故障、段错等执行指令引起的故障异常，由于指令并没有执行，所以断点应该是异常指令的PC值
  + 中断识别
    + 根据当前的中断请求识别出中断来源，也就是发生了什么中断，并将对应中断的中断服务程序入口地址送程序计数器PC

# 第九章 输入输出系统
## 输入输出设备与特性
+ 异步性
+ 实时性
+ 独立性

磁盘、网卡既能输入也能输出，就叫“输入输出设备”  
键盘只能输入，就叫输入设备  
只能输出就叫输出设备  

### 输入/输出系统的组成与功能
+ 外部设备、接口部件、总线以及响应的管理软件统称为计算机的输入输出系统，简称IO系统
  + I/O硬件
    + 外设、控制器、I/O接口、总线
  + I/O软件
    + OSA无关库，设备无关库，驱动
+ 主要功能
  + 完成计算机内部二进制信息与外部i多种信息形式间的交流
  + 保证CPU能够正确选择I/O设备并实现对其控制，与数据传输
  + 利用数据缓冲、合适的数据传送方式，实现主机外设间速度匹配

## I/O接口
+ I/O接口：连接总线与I/O设备的物理和逻辑界面
  + 既包括物理连接电路，也包括软件逻辑接口
  + 所有设备均通过I/O接口（总线接口）与总线相连
  + CPU使用设备地址经总线与I/O接口通信访问I/O设备
  + 标准接口有利于提升I/O系统的独立性，降低连接复杂度
+ I/O接口功能
  + 设备寻址
  + 数据交互
  + 设备控制
  + 状态检测
  + 数据缓冲
  + 格式转换
+ I/O接口编址
  + 统一编址
    + 内存映射编址（Memory-mapped）
    + 外设地址与内存地址统一编址，同一个地址空间
    + 不需要设置专用的I/O指令
    + 采用访存指令访问外设，具体访问什么设备取决于地址
  + 独立编址
    + 端口映射编址（Port-mapped）
    + I/O地址空间与主存地址空间相互独立
    + I/O地址又称为I/O端口
    + 不同设备中的不同寄存器和存储器都又唯一的端口地址
    + 使用I/O指令访问外设
+ I/O接口的软件
  + 现代计算机中用户必须通过操作系统间接访问设备，屏蔽设备细节，更加方便。
  + 与OS无关的I/O库（用户态）
    + 如C语言中的标准I/O库stdio.h。用户程序主要通过调用I/O库访问设备，方便程序在不同OS间移植
  + 与设备无关的OS调用库（内核态）
    + open,read, write, seek,ioctl,close等
  + 独立的设备驱动程序（内核态）
    + 设备驱动程序是与设备相关的I/O软件部分
    + 不同设备对应不同的驱动程序
    + 遵循具体设备的I/O接口约定，包含设备接口细节
+ I/O接口分类
  + 按数据传送方式
    + 并行
    + 串行
  + 按接口的灵活性
    + 可编程接口
    + 不可变成接口
  + 按通用性
    + 通用
    + 专用
  + 按总线传输的通信方式
    + 同步
    + 异步
  + 按访问外设的方式
    + 直接传送方式
    + 程序控制方式
    + 程序中断方式
    + DMA
    + 通道处理机接口

## 数据传送控制方式
+ 程序查询方式
  + 轮询
  + 定时
+ 程序中断方式
+ 直接内存访问方式
+ 通道方式
+ 外围处理机方式
## 程序控制方式

## 程序中断方式
+ 提高了CPU的使用效率
  + 主动告知机制避免了反复查询设备状态
  + 仍需要CPU占用（中断服务子程序运行时间+中断开销）
+ 适合随机出现的服务
+ 需要专门的硬件
+ 子程序与中断服务子程序的异同
  + 共同点：调用后要返回
  + 差异：调用方式（显式/随机），保存寄存器（中断更多），返回位置与方式（调用位置/中断位置）
+ 当同时有多个中断的时候，要进行中断仲裁
  + 优先级高的先响应
  + CPU优先级随不同中断服务程序而改变
    + 执行某设备中断服务子程序，CPU优先级就与该设备的优先级一样
  + 单级中断与多重中断
    + 单级中断
      + 所有中断源同一个级别，离CPU近的优先级高
      + CPU处理某个中断时，不响应其它中断
    + 多重中断
      + 优先级高的中断可以打断优先级低的中断服务程序
      + 中断嵌套
  + 划分优先级的一般规律
    + 硬件故障中断属于最高级，其次是程序错误中断
    + 非屏蔽中断优于可屏蔽中断
    + DMA请求优先于I/O设备传送的中断请求
    + 告诉设备优于低俗设备
    + 输入设备的中断优于输出设备
    + 实时设备优先于普通设备
  + 中断屏蔽：动态改变各设备的处理优先级
+ 中断识别（寻找入口地址）
  + 独立请求：向量中断
    + 将服务程序入口（中断向量）组织在中断向量表中；响应时由硬件直接产生中断号（向量地址），查中断向量表取得服务程序入口，转入响应服务程序。
    + 硬件查询法
  + 中断共享：非向量中断
    + 将服务程序入口组织在查询程序中
    + 响应时执行查询程序查询你中断源，查询特定端口GPIO识别中断源
    + 程序识别（软件方法）
+ 中断处理中的问题
  + 中断响应条件
    + 中断允许触发器IE=1
    + 对应的中断未被屏蔽
    + 无更高优先级的DMA请求
    + 中断嵌套必须优先级更高
    + 指令已经执行完最后一个机器周期
      + 保证指令执行的完整性
  + 保存现场，恢复现场
    + 中断程序用到的通用寄存器，EPC，屏蔽字
    + 缺页异常的断点和外部中断断点不一致
  + 中断过程由软硬件结合完成
## DMA方式
+ 基本概念
  + 外设于主存间建立一个由硬件管理的数据通路（虚拟通路，还是通过系统总线）
  + CPU不介入外设于主存的数据传送操作
  + 减少CPU开销，提升效率
+ 与CPU访存冲突
  + 停止CPU使用主存
    + DMA传送数据时，CPU停止使用主存
    + 一批数据传送结束后，DMA再交还主存使用权
    + DMA传送过程中，CPU处于等待状态
  + DMA与CPU交替使用主存
    + 每个存储周期分成两段
      + 一段用于DMA访问主存
      + 一段用于CPU访问主存
    + 无主存使用权移交过程
  + 周期挪用法
    + DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行
    + CPU现场没有变动，仅延缓了指令的执行
    + 如发生访存冲突，DMA优先访问
+ DMA与程序中断的区别
  + 中断通过程序传送数据，DMA靠硬件实现
  + 中断实际为两指令之间，DMA响应实际为两存储周期之间
  + 中断不仅具有数据传送能力，还能处理异常事件。DMA只能进行数据传送。
  + DMA仅挪用了一个存储周期，不改变CPU现场。
  + DMA请求的优先级比中断请求高。CPU优先响应DMA请求，是为了避免DMA所连接的告诉外设丢失数据
  + DMA利用了中断的技术
## 通道方式

## 常见I/O设备


# 错题总结话术：
+ 从软硬协同的角度分析运算器提供硬件溢出检测机制的意义：
  + 硬件提供溢出检测后，程序员可以通过该溢出位判断溢出与否，而不再需要通过专门程序判断溢出，简化了程序设计，利于流水线CPU的高效运行。
+ 如果要将单周期CPU变成多周期，应该左什么变化
  + 将指令存储器和数据存储器合二为一；每个功能部件后增加一个缓冲器，如主存、寄存器堆、ALU等部件后都要增加
+ 如果多周期MIPS CPU采用微程序控制器，若要加入中断逻辑，应进行哪些扩展？
  + 微程序中需要增加中断隐指令的微程序，该微程序的功能是保存断点，修改PC地址为中断程序入口地址，微指令P字段需要再增加一位用于中断判断$P_{end}$，每条指令对应微程序最后一条指令的中断判断位为1，如果当前有中断请求信号，要进行分支跳转中断隐指令对应的微程序
+ 在定长指令周期三级时许总线CPU实验中，测试程序预期功能是在0x80的内存数据单元进行排序，请问这个排序是降序还是升序？（**降序**）是由符号比较还是无符号比较？（**有符号比较**）为什么实际Educoder平台上通关的结果是在0x00处进行内存的安源数据排序的，而且代码区部分代码会被覆盖？
  + Z寄存器没有锁存控制，采用定长周期时，刚刚计算完的地址应该直接送AR，但是由于计算周期和执行周期之间插入了空周期，所以导致送入AR中的地址错误。
+ 如果要为CPU增加单级中断处理机制，需要增加哪些硬件单元，并叙述其功能。
  + EPC：保存断点
  + 中断使能寄存器IE：开关中断
  + 中断识别控制逻辑：中断识别
+ 如果要为CPU增加单级中断处理机制，在软件以及软硬系统方面需要进行哪些修改。
  + 中断返回eret指令的支持
  + 编写中断服务程序：保护线程、中断服务、恢复现场、中断返回
+ CRC编码实验中，对16位汉字进行编码，选择生成多项式7位，余数6位，能够区分一位错和两位错，直接通过余数区分。